#use_extension("@build_bazel_rules_nodejs //:index.bzl", "yarn_install")

###############################################################################
# Bazel now uses Bzlmod by default to manage external dependencies.
# Please consider migrating your external dependencies from WORKSPACE to BUILD.bazel.
#
# For more details, please check https://github.com/bazelbuild/bazel/issues/18958
###############################################################################
module(
    name = "bazel_project2",
    version = "1.0.0",
)

bazel_dep(name = "rules_cc", version = "0.2.2")
bazel_dep(name = "googletest", version = "1.15.2")
bazel_dep(name = "pybind11_bazel", version = "2.13.6")
bazel_dep(name = "aspect_bazel_lib", version = "2.8.1")
bazel_dep(name = "container_structure_test", version = "1.16.0")
bazel_dep(name = "rules_jvm_external", version = "6.3")
bazel_dep(name = "rules_oci", version = "2.2.6")
bazel_dep(name = "rules_java", version = "8.11.0")
bazel_dep(name = "fmt", version = "11.2.0")
#bazel_dep(name = "ffmpeg_bazel_build", version = "8.11.0")
#git_override(
#    module_name = "ffmpeg_bazel_build",
#    commit = "01e1d136f85af8be10453224dcf7445f0d1bcabd",
#    remote = "https://github.com/jonnrb/bazel_ffmpeg.git",
#)

# File: MODULE.bazel
bazel_dep(name = "rules_python", version = "1.5.0")
bazel_dep(name = "platforms", version = "1.0.0")

# 引入 rules_nodejs
#bazel_dep(name = "rules_nodejs", version = "6.5.0")

PYTHON_VERSION = "3.12"

# Configure Python toolchain
python = use_extension("@rules_python//python/extensions:python.bzl", "python")
python.toolchain(
    configure_coverage_tool = True,
    is_default = True,
    python_version = PYTHON_VERSION,
)

pip = use_extension("@rules_python//python/extensions:pip.bzl", "pip")
pip.parse(
    #    name = "pip_deps",
    hub_name = "pip_deps2",
    #    overrides = {
    #        "fastapi": {
    #            "build_file": "//third_party:fastapi.BUILD",
    #        },
    #    },
    python_version = PYTHON_VERSION,
    requirements_lock = "//:requirements_lock_3_12.txt",
)
use_repo(pip, "pip_deps2")

bazel_dep(name = "glog", version = "0.5.0", repo_name = "com_github_google_glog")

# Override glog to a fork version with archive_override.
archive_override(
    module_name = "glog",
    integrity = "sha256-EH4o3n+qkfcsEFODkkRzs1/XAH9ej2V77gv05eplB5k=",
    strip_prefix = "glog-9401faa19e0424791243827b8e95efd3d0d8db23",
    urls = ["https://github.com/meteorcloudy/glog/archive/9401faa19e0424791243827b8e95efd3d0d8db23.tar.gz"],
)

# Override gflag to a fork version with git_override.
# gflag is still an indirect dependency, the override itself doesn't give the root module visibility on gflags.
git_override(
    module_name = "gflags",
    commit = "95995169e86f3fedd19696df5b1811d441c462a2",
    remote = "https://github.com/meteorcloudy/gflags.git",
)

# Patch bazel skylib 1.7.1 with a local patch file.
bazel_dep(name = "bazel_skylib", version = "1.7.1")
single_version_override(
    module_name = "bazel_skylib",
    patch_strip = 1,
    patches = ["//override_bazel_module_demo:bazel_skylib.patch"],
    version = "1.7.1",
)

# Depend on module lib_a at a local path.
# The bazel_dep statement is necessary because the root module must have visibility on override_bazel_module_demo.
#bazel_dep(name = "override_bazel_module_demo", version = "0.0.1")
#local_path_override(
#    module_name = "override_bazel_module_demo",
#    path = "./override_bazel_module_demo",
#)

bazel_dep(name = "lib_a", version = "0.0.1")
local_path_override(
    module_name = "lib_a",
    path = "./extern_repo/lib_a",
)

# 使用我们定义的模块扩展
my_ext = use_extension("//module_extension:extensions.bzl", "my_extension")

# 为扩展添加标签(tags)
my_ext.dep(name = "guava")
my_ext.dev(name = "guava_dev")
my_ext.dep(
    name = "gson",
    version = "2.8.10",
)
use_repo(my_ext, "myrepo")  # 这会让所有生成的仓库对模块可用

maven = use_extension("@rules_jvm_external//:extensions.bzl", "maven")
maven.install(
    artifacts = [
        "junit:junit:4.12",
        "com.google.guava:guava:28.0-jre",
    ],
    fetch_sources = True,
    repositories = [
        "https://maven.aliyun.com/repository/public",
        "http://uk.maven.org/maven2",
        "https://jcenter.bintray.com/",
    ],
)
use_repo(maven, "maven")

oci = use_extension("@rules_oci//oci:extensions.bzl", "oci")
oci.pull(
    name = "distroless_java",
    digest = "sha256:161a1d97d592b3f1919801578c3a47c8e932071168a96267698f4b669c24c76d",
    image = "gcr.io/distroless/java17",
)
use_repo(oci, "distroless_java")

my_extension = use_extension("//repo_rule_demo:my_extension.bzl", "my_extension")
my_extension.lib(
    sha256 = "abc123...",
    url = "https://github.com/google/googletest/releases/download/v1.17.0/googletest-1.17.0.tar.gz",
    version = "1.0.0",
)

#  my_external_lib_1_0_0_ref is not what i think the reference of my_external_lib_1_0_0
#
use_repo(my_extension, "my_external_lib_1_0_0")

bazel_dep(name = "my-panio", version = "1.7.1")
#bazel_dep(name = "rules_rust", version = "0.63.0")

local_path_override(
    module_name = "my-panio",
    #    build_file = "java_demo/BUILD.panio",
    path = "third_party/my-panio",
)

bazel_dep(name = "abseil-cpp", version = "20250814.0")

llvm = use_extension("//:llvm_extension.bzl", "llvm")
use_repo(
    llvm,
    "llvm-project",
    "llvm_zlib",
    "llvm_zstd",
)

# 以下的语句是llvm中的文件会帮着生成一系列的*.bazel *.bzl的文件, 因为他本身只支持linux环境, 所以, 我们
# 需要自己去配置这些信息
# The subset of LLVM backend targets that should be compiled
#_LLVM_TARGETS = [
#   "X86",
#]
# Configure LLVM project using use_repo_rule
#llvm_configure = use_repo_rule("@llvm-raw//utils/bazel:configure.bzl", "llvm_configure")
#
#llvm_configure(
#    name = "llvm-project",
#    targets = _LLVM_TARGETS,
#)

bazel_dep(name = "nanobind_bazel", version = "2.8.0")

# 加载自定义扩展
vcpkg = use_extension("//:vcpkg_extension.bzl", "vcpkg")
use_repo(vcpkg, "vcpkg")

# Register the xxxxxx_hello_world repository
# 这块隐藏的代码不起作用,起作用的是下面的use_repo_rule

#hello_ext = use_extension("//:repo_ext.bzl", "hello_ext")
#hello_ext.door()
#hello_ext.door()
#hello_ext.door()
#hello_ext.table()
#hello_ext.add_hello()
##use_repo(hello_ext, "xxxxxx_hello_world")

hello_repo_rule = use_repo_rule(
    "//:repo_ext.bzl",
    "hello_repo",
)

hello_repo_rule(
    name = "hello_mod_ext",
)

#
bazel_dep(name = "my_patch_demo", version = "0.0.1")

#local_path_override(
#    module_name = "my_patch_demo",
#    #    build_file = "third_party/BUILDS/my_patch_demo.bazel",
#    path = "//third_party/my_patch_demo",
#)
#
#single_version_override(
#    module_name = "my_patch_demo",
#    patch_strip = 1,  # 剥离路径前缀的层级
#    patches = [
#        "//third_party/patches/my_patch_demo/BUILD.patch",
#        "//third_party/patches/my_patch_demo/hello.patch",
#        "//third_party/patches/my_patch_demo/MODULE.patch",
#    ],  # 补丁文件路径
#    version = "0.0.1",
#)

git_override(
    module_name = "my_patch_demo",
    commit = "4de3aa7ea83acaa2b8ce1f2ab1ec29c618052d91",
    patch_strip = 1,
    patches = [
        "third_party/patches/my_patch_demo/BUILD.patch",
        "third_party/patches/my_patch_demo/hello.patch",
        "third_party/patches/my_patch_demo/MODULE.patch",
    ],  # 补丁文件路径
    remote = "https://github.com/yingliufengpeng/my_patch_demo.git",  # ✅ 直接路径
)
